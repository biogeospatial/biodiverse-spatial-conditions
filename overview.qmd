# Overview

## Uses for spatial conditions

Spatial conditions are used both to define the neighbourhoods of the
spatial analyses and the definition queries used to constrain the set of
groups used in the analyses.

### Neighbourhoods

Neighbourhoods are essential for any spatial analysis, as it is through
these that one can define the set of groups to be considered in an
analysis. In the moving window analyses these determine which groups are
compared with which other groups. In the cluster analyses they determine
which groups are considered candidates to be clustered together. It is
also possible to define neighbourhoods for spatially constrained
randomisations (see [Laffan and Crisp, 2003, J
Biogeog](https://doi.org/10.1046/j.1365-2699.2003.00875.x){.external
target=\"\_blank\"}).

Before we describe the process, some definitions are needed. The
**processing group** is the group being considered in the analysis at
some iteration, and to which the results for that iteration are
assigned. A group is a member of the processing group\'s set of
neighbours (is a **neighbouring group**) if the spatial condition
evaluates to true.

A [spatial
analysis](https://biogeospatial.github.io/biodiverse-quick-start/5-data-analysis.html#running-a-spatial-moving-window-analysis){.external
target=\"\_blank\"} progressively iterates over each group that passes
the definition query, assessing every other group for membership in
neighbour set 1 or 2. The selected indices are then calculated using the
groups that occur in neighbour sets 1 and 2 (and their labels and other
properties as required by the
[calculations](https://github.com/shawnlaffan/biodiverse/wiki/Indices){.external
target=\"\_blank\"}).

### Definition Queries

These differ from neighbourhoods as they assess only the processing
group to determine if calculations should be run for it or not. They use
the same syntax as for neighbourhoods, but the system will commonly
complain if a condition requiring a neighbouring group is used.

Note that groups that fail the definition query are still considered for
membership of neighbour sets of those that pass. Use a definition query
in conjunction with an appropriate neighbourhood definition if you want
to exclude some groups from neighbour sets as well. For example, you
could use `sp_match_text (axis => 2, text => 'fred', type => 'proc')`
for the definition query and
`sp_match_text (axis => 2, text => 'fred', type => 'nbr')` for the
neighbourhood. This will restrict calculations to those groups with a
third axis of \'fred\', and also exclude any group without fred in the
third axis from the neighbour sets of those groups processed.

## Some details

As with any system, there must be compromises between ease of use and
system flexibility. In this case we have opted for system flexibility by
direct use of Perl syntax. This means you can use arbitrarily complex
functions to define neighbourhoods, including loops and other multiple
variable conditions. This may be horrifying to non-perlers, as one of
the main complaints about perl is its complex grammar and syntax. To
alleviate this we are encapsulating many of the common conditions in
subroutines that can be called by name with a set of arguments. We have
also provided examples below to assist.

The neighbourhood and definition query interfaces have a syntax
verification button to check that the syntax is valid. This does not,
however, guarantee your parameters will work, only that it is valid Perl
code. (The reality here is that we will just evaluate the parameter
statement with some default values and warn you if the system raises
some sort of error or exception).

### Locale issues

If you are using a locale where the radix character (the decimal place
marker) is a comma then you need to remember to use a dot instead. For
example, this code `sp_circle (radius => 5,3)` should be
`sp_circle (radius => 5.3)` or you will receive warnings about uneven
arguments used to define a hash.

## Evaluation

This is a brief description of the evaluation process used to determine
the set of neighbours for a group.

Currently the system operates on boolean membership of the set of
neighbours, so a group either is or is not a neighbour of the processing
group. If no spatial index is used then every group\'s membership of the
processing cell\'s neighbour set is considered in turn. If a spatial
index is used then only a subset of neighbours is considered (those
within the relevant spatial index blocks). This is why processing times
are usually shorter when using an index ([more details
here](https://biogeospatial.github.io/biodiverse-quick-start/5-data-analysis.html#building-a-spatial-index){.external
target=\"\_blank\"}).

Spatial conditions need not return symmetric sets. In this way group *i*
can be in group *j*\'s neighbour set, but *j* need not be in *i*\'s
neighbour set. This is not an issue for moving window analyses, but can
cause asymmetric dissimilarity matrices if used to run a spatially
constrained cluster analysis. This is why it is generally a good idea in
these cases to set the second neighbourhood to be `sp_select_all()` or
`1` (which is the same thing).

In the calculations, groups in neighbour set 1 are excluded from
neighbour set 2 so there are no overlaps that would violate the
comparison calculations.

The conditions are specified using some combination of pre-defined
functions, pre-specified variables, and/or user defined variables and
functions. These are now described.
