[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Biodiverse Spatial Conditions",
    "section": "",
    "text": "1 Introduction\nSpatial conditions are core to the Biodiverse system. They are used to specify both neighbourhoods used in the analyses, and also the definition queries used to restrict the calculations to a subset of groups.\nThis document provides an overview of using these conditions, lists the available conditions and describes how to use variables, both predefined and user defined.\nThis document describes version 5.0\nBiodiverse is a tool for the spatial analysis of biological and related diversity.\nFor more information about Biodiverse see:\nWeb site: http://shawnlaffan.github.io/biodiverse/\nThe blog provides updates and tips about functionality. It can be accessed through http://biodiverse-analysis-software.blogspot.com.au/\nIf you have question about the software then please start a discussion at https://github.com/shawnlaffan/biodiverse/discussions or post a question at https://groups.google.com/forum/#!forum/biodiverse-users\nThis work is licensed under a Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "overview.html",
    "href": "overview.html",
    "title": "2  Overview",
    "section": "",
    "text": "2.1 Uses for spatial conditions\nSpatial conditions are used both to define the neighbourhoods of the spatial analyses and the definition queries used to constrain the set of groups used in the analyses.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Overview</span>"
    ]
  },
  {
    "objectID": "overview.html#uses-for-spatial-conditions",
    "href": "overview.html#uses-for-spatial-conditions",
    "title": "2  Overview",
    "section": "",
    "text": "Neighbourhoods\nNeighbourhoods are essential for any spatial analysis, as it is through these that one can define the set of groups to be considered in an analysis. In the moving window analyses these determine which groups are compared with which other groups. In the cluster analyses they determine which groups are considered candidates to be clustered together. It is also possible to define neighbourhoods for spatially constrained randomisations (see Laffan and Crisp, 2003, J Biogeog).\nBefore we describe the process, some definitions are needed. The processing group is the group being considered in the analysis at some iteration, and to which the results for that iteration are assigned. A group is a member of the processing group's set of neighbours (is a neighbouring group) if the spatial condition evaluates to true.\nA spatial analysis progressively iterates over each group that passes the definition query, assessing every other group for membership in neighbour set 1 or 2. The selected indices are then calculated using the groups that occur in neighbour sets 1 and 2 (and their labels and other properties as required by the calculations).\n\n\nDefinition Queries\nThese differ from neighbourhoods as they assess only the processing group to determine if calculations should be run for it or not. They use the same syntax as for neighbourhoods, but the system will commonly complain if a condition requiring a neighbouring group is used.\nNote that groups that fail the definition query are still considered for membership of neighbour sets of those that pass. Use a definition query in conjunction with an appropriate neighbourhood definition if you want to exclude some groups from neighbour sets as well. For example, you could use sp_match_text (axis =&gt; 2, text =&gt; 'fred', type =&gt; 'proc') for the definition query and sp_match_text (axis =&gt; 2, text =&gt; 'fred', type =&gt; 'nbr') for the neighbourhood. This will restrict calculations to those groups with a third axis of 'fred', and also exclude any group without fred in the third axis from the neighbour sets of those groups processed.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Overview</span>"
    ]
  },
  {
    "objectID": "overview.html#some-details",
    "href": "overview.html#some-details",
    "title": "2  Overview",
    "section": "2.2 Some details",
    "text": "2.2 Some details\nAs with any system, there must be compromises between ease of use and system flexibility. In this case we have opted for system flexibility by direct use of Perl syntax. This means you can use arbitrarily complex functions to define neighbourhoods, including loops and other multiple variable conditions. This may be horrifying to non-perlers, as one of the main complaints about perl is its complex grammar and syntax. To alleviate this we are encapsulating many of the common conditions in subroutines that can be called by name with a set of arguments. We have also provided examples below to assist.\nThe neighbourhood and definition query interfaces have a syntax verification button to check that the syntax is valid. This does not, however, guarantee your parameters will work, only that it is valid Perl code. (The reality here is that we will just evaluate the parameter statement with some default values and warn you if the system raises some sort of error or exception).\n\nLocale issues\nIf you are using a locale where the radix character (the decimal place marker) is a comma then you need to remember to use a dot instead. For example, this code sp_circle (radius =&gt; 5,3) should be sp_circle (radius =&gt; 5.3) or you will receive warnings about uneven arguments used to define a hash.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Overview</span>"
    ]
  },
  {
    "objectID": "overview.html#evaluation",
    "href": "overview.html#evaluation",
    "title": "2  Overview",
    "section": "2.3 Evaluation",
    "text": "2.3 Evaluation\nThis is a brief description of the evaluation process used to determine the set of neighbours for a group.\nCurrently the system operates on boolean membership of the set of neighbours, so a group either is or is not a neighbour of the processing group. If no spatial index is used then every group's membership of the processing cell's neighbour set is considered in turn. If a spatial index is used then only a subset of neighbours is considered (those within the relevant spatial index blocks). This is why processing times are usually shorter when using an index (more details here).\nSpatial conditions need not return symmetric sets. In this way group i can be in group j's neighbour set, but j need not be in i's neighbour set. This is not an issue for moving window analyses, but can cause asymmetric dissimilarity matrices if used to run a spatially constrained cluster analysis. This is why it is generally a good idea in these cases to set the second neighbourhood to be sp_select_all() or 1 (which is the same thing).\nIn the calculations, groups in neighbour set 1 are excluded from neighbour set 2 so there are no overlaps that would violate the comparison calculations.\nThe conditions are specified using some combination of pre-defined functions, pre-specified variables, and/or user defined variables and functions. These are now described.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Overview</span>"
    ]
  },
  {
    "objectID": "spatial_conditions.html",
    "href": "spatial_conditions.html",
    "title": "3  Functions",
    "section": "",
    "text": "3.1 Available functions\nFunctions are the easiest way to specify conditions as one does not need to wrestle with variables. Functions also set metadata to tell the system how to use the spatial index. The spatial index saves considerable processing time for large data sets as the system does not need to test many pairs of index blocks to determine which to use. If you use a function for which an index will produce erroneous results then the system sets a flag to ignore it. You can also disable it in the settings for a spatial condition.\nThe available functions in version 5.0 are: sp_annulus, sp_block, sp_circle, sp_circle_cell, sp_ellipse, sp_get_spatial_output_list_value, sp_group_not_empty, sp_in_label_ancestor_range, sp_in_label_range, sp_in_line_with, sp_is_left_of, sp_is_right_of, sp_match_regex, sp_match_text, sp_point_in_cluster, sp_point_in_poly, sp_point_in_poly_shape, sp_points_in_same_cluster, sp_points_in_same_poly_shape, sp_rectangle, sp_redundancy_greater_than, sp_richness_greater_than, sp_select_all, sp_select_block, sp_select_element, sp_select_sequence, sp_self_only, sp_spatial_output_passed_defq, sp_square, sp_square_cell,",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "spatial_conditions.html#available-functions",
    "href": "spatial_conditions.html#available-functions",
    "title": "3  Functions",
    "section": "",
    "text": "sp_annulus\nAn annulus. Assessed against all dimensions by default but use the optional axes =&gt; [] arg to specify a subset. Uses group (map) distances.\nRequired args: inner_radius, outer_radius\nOptional args: axes\nExample:\n#  an annulus assessed against all axes\nsp_annulus (inner_radius =&gt; 2000000, outer_radius =&gt; 4000000)\n\n#  an annulus assessed against axes 0 and 1\nsp_annulus (inner_radius =&gt; 2000000, outer_radius =&gt; 4000000, axes =&gt; [0,1])\n\n\nsp_block\nA non-overlapping block. Set an axis to undef to ignore it.\nRequired args: size\nOptional args: origin\nExample:\nsp_block (size =&gt; 3)\nsp_block (size =&gt; [3,undef,5]) #  rectangular block, ignores second axis\n\n\nsp_circle\nA circle. Assessed against all dimensions by default (more properly called a hypersphere) but you can use the optional axes =&gt; [] arg to specify a subset. Uses group (map) distances.\nRequired args: radius\nOptional args: axes\nExample:\n#  A circle of radius 1000 across all axes\nsp_circle (radius =&gt; 1000)\n\n#  use only axes 0 and 3\nsp_circle (radius =&gt; 1000, axes =&gt; [0, 3])\n\n\nsp_circle_cell\nA circle. Assessed against all dimensions by default (more properly called a hypersphere) but you can use the optional axes =&gt; [] arg to specify a subset. Uses cell (map) distances.\nRequired args: radius\nOptional args: none\nExample:\n#  A circle of radius 3 cells across all axes\nsp_circle (radius =&gt; 3)\n\n#  use only axes 0 and 3\nsp_circle_cell (radius =&gt; 3, axes =&gt; [0, 3])\n\n\nsp_ellipse\nA two dimensional ellipse. Use the axes argument to control which are used (default is [0,1]). The default rotate_angle is 0, such that the major axis is east-west.\nRequired args: major_radius, minor_radius\nOptional args: axes, rotate_angle, rotate_angle_deg\nExample:\n# North-south aligned ellipse\nsp_ellipse (\n    major_radius =&gt; 300000,\n    minor_radius =&gt; 100000,\n    axes         =&gt; [0,1],\n    rotate_angle =&gt; 1.5714,\n)\n\n\nsp_get_spatial_output_list_value\nObtain a value from a list in a previously calculated spatial output.\nRequired args: index, output\nOptional args: element, list, no_error_if_no_index\nExample:\n#  Get the spatial results value for the current neighbour group\n# (or processing group if used as a def query)\nsp_get_spatial_output_list_value (\n    output  =&gt; 'sp1',              #  using spatial output called sp1\n    list    =&gt; 'SPATIAL_RESULTS',  #  from the SPATIAL_RESULTS list\n    index   =&gt; 'PE_WE_P',          #  get index value for PE_WE_P\n)\n\n#  Get the spatial results value for group 128:254\n#  Note that the SPATIAL_OUTPUTS list is assumed if\n#  no 'list' arg is passed.\nsp_get_spatial_output_list_value (\n    output  =&gt; 'sp1',\n    element =&gt; '128:254',\n    index   =&gt; 'PE_WE_P',\n)\n\n\nsp_group_not_empty\nIs a basedata group non-empty? (i.e. contains one or more labels)\nRequired args: none\nOptional args: element\nExample:\n# Restrict calculations to those non-empty groups.\n#  Will use the processing group if a def query,\n#  the neighbour group otherwise.\nsp_group_not_empty ()\n\n# The same as above, but being specific about which group (element) to test.\n#  This is probably best used in cases where the element\n#  to check is varied spatially.}\nsp_group_not_empty (element =&gt; '5467:9876')\n\n\nsp_in_label_ancestor_range\n(Available from version 5.1)\nIs a group within the range of a label's ancestor?\nReturns true if the group falls within the range of any of the any of the ancestor's terminal descendant ranges. The range is by default defined as the set of groups in the basedata containing that label. Polygons can also be specified (see below).\nThe ancestor is by default defined by length along the path to the root node. Setting the by_depth option to true uses the number of ancestors. The by_tip_count option finds the first ancestor with at least the target number of tips while by_desc_count uses the number of descendants (tips and internals). The by_len_sum finds the first ancestor for which the sum of its descendant branch lengths plus its own length is greater than the target.\nNegative target values with by_length or by_depth search the path from the root to the specified node. However, if a by_*_count option is used then a negative target is treated as zero and returns the specified label range is returned.\nThe target argument determines how far up or down the tree the ancestor is searched for. When using length, the distance includes the tipwards extent of the branch. The depth is calculated as the number of ancestors.\nIf the target value exceeds that to (or of) the root node then the root or label node is returned for positive or negative dist values, respectively.\nAn internal branch can be specified as the label. Specifying a target of 0 for an internal node is one means to use the range of an internal node.\nReturns false if the label is not associated with a node on the tree.\nWhen the as_frac argument is true then target is treated as a fraction of the distance to the root node, the number of tips, or the sum of all branches, as appropriate.\nIf the eq argument is true then the branch lengths are all treated as of equal length (the mean of the non-zero branch lengths), although zero length branches remain zero. This is the same as the alternate tree used in CANAPE.\nIf the rw argument is true then the branches are range weighted. This is the same as the range weighted tree in CANAPE. When both eq and rw are true then this is the same as the range weighted alternate tree in CANAPE\nThe underlying algorithm checks each of the terminal ranges using sp_in_label_range(). This means the search can also use the convex/concave hull or circumcircle of each terminal, as well as setting other arguments such as the buffer_dist and using a default label in some circumstances.\nNote that the range of each of the ancestor's tips is assessed separately, i.e. the union of the hulls/circles is used. The ranges are not aggregated before a hull or circumcircle is calculated.\nRequired args: label, target\nOptional args: allow_holes, as_frac, axes, buffer_dist, by_depth, by_tip_count, circumcircle, concave_hull, convex_hull, hull_ratio, type\nExample:\n# Are we in the range of an ancestor of Genus:Sp1?\nsp_in_label_ancestor_range(label =&gt; 'Genus:Sp1', target =&gt; 0.5)\n\n# Are we in the range of the \"grandmother\" of Genus:Sp1?\nsp_in_label_ancestor_range(\n  label    =&gt; 'Genus:Sp1',\n  target   =&gt; 2,\n  by_depth =&gt; 1,\n)\n\n# Are we in the range of the first ancestor with 6 or more tips?\nsp_in_label_ancestor_range(\n  label        =&gt; 'Genus:Sp1',\n  target       =&gt; 6,\n  by_tip_count =&gt; 1,\n)\n\n#  Are we in any of the tips' convex hulls?\nsp_in_label_ancestor_range(\n  label       =&gt; 'Genus:Sp1',\n  target      =&gt; 0.5,\n  convex_hull =&gt; 1,\n)\n\n#  Are we in any of the tips' concave hulls with a ratio parameter of 0.5?\nsp_in_label_ancestor_range(\n  label        =&gt; 'Genus:Sp1',\n  target       =&gt; 0.5,\n  concave_hull =&gt; 1,\n  hull_ratio   =&gt; 0.5,\n)\n\n#  Are we in any of the tips' circumscribing circles?\nsp_in_label_ancestor_range(\n  label        =&gt; 'Genus:Sp1',\n  target       =&gt; 0.5,\n  circumcircle =&gt; 1,\n)\n\n#  Are we in the range of the ancestor for which the sum of\n#  branch lengths below and including it is 10,000?\nsp_in_label_ancestor_range(\n  label      =&gt; 'Genus:Sp1',\n  target     =&gt; 10000,\n  by_len_sum =&gt; 1,\n)\n\n#  Are we in the range of the ancestor for which the sum of\n#  number of branches below is at least 10?\nsp_in_label_ancestor_range(\n  label      =&gt; 'Genus:Sp1',\n  target     =&gt; 10,\n  by_desc_count =&gt; 1,\n)\n\n\n\nsp_in_label_range\n(Available from version 5.1)\nIs a group within a label's range?\nThis is by default assessed as a check of whether the label is found in the processing group but can be generalised by using the convex_hull, concave_hull or circumcircle arguments.\nThe type argument determines if the processing or neighbour group is assessed. Normally this can be left as the default.\nThe convex_hull returns true if the processing group is within the convex hull defined by the groups that form the label range.\nThe circumcircle returns true if the processing group is within the minimum circumscribing circle that includes all of the label range groups.\nThe concave_hull returns true if the processing group is within the concave hull defined by the groups that form the label range. The concavity can be controlled by the hull_ratio argument, and holes can be allowed by setting the boolean argument allow_holes to a true value.\nBoth the latter two arguments use the first two axes by default and will return an error if there is only one group axis in the basedata. If you have more than two axes and wish to assess different ones then pass the axes argument. (This argument is ignored for the default case as it does a direct comparison of the group names).\nIf more than one of convex_hull, concave_hull and circumcircle arguments are passed then only one i run. The convex hull takes priority, followed by the circumcircle, and lastly the concave hull.\nAn optional buffer_dist argument can be used to adjust the size of the convex/concave hull or circumcircle. As is standard with GIS buffering, positive values increase the area while negative values shrink it.\nThe label argument should normally be specified but in some circumstances a default is set (e.g. when a randomisation seed location is set).\nRequired args: label\nOptional args: allow_holes, axes, buffer_dist, circumcircle, concave_hull, convex_hull, hull_ratio, type\nExample:\n# Are we in the range of label called Genus:Sp1?\nsp_in_label_range(label =&gt; 'Genus:Sp1')\n\n#  Are we in the convex hull?\nsp_in_label_range(label =&gt; 'Genus:Sp1', convex_hull =&gt; 1)\n\n#  Are we in the maximally concave hull?\nsp_in_label_range(label =&gt; 'Genus:Sp1', concave_hull =&gt; 1)\n\n#  Are we in a slightly less concave hull?\nsp_in_label_range(label =&gt; 'Genus:Sp1', concave_hull =&gt; 1, hull_ratio =&gt; 0.3)\n\n#  Are we in a slightly less concave hull allowing for holes?\nsp_in_label_range(\n    label        =&gt; 'Genus:Sp1',\n    concave_hull =&gt; 1,\n    hull_ratio   =&gt; 0.3,\n    allow_holes  =&gt; 1,\n)\n\n#  Are we in the circumscribing circle?\nsp_in_label_range(label =&gt; 'Genus:Sp1', circumcircle =&gt; 1)\n\n#  Are we in the convex hull with a buffer of 100,000 units?\nsp_in_label_range(\n    label       =&gt; 'Genus:Sp1',\n    convex_hull =&gt; 1,\n    buffer_dist =&gt; 100000,\n)\n\n#  Buffers can be negative, in which case the\n#  convex/concave hull or circumcircle is shrunk\nsp_in_label_range(\n    label       =&gt; 'Genus:Sp1',\n    convex_hull =&gt; 1,\n    buffer_dist =&gt; -100000,\n)\n\n#  Are we in the convex hull defined using the\n#  coordinates from the third and first axes?\nsp_in_label_range(\n    label       =&gt; 'Genus:Sp1',\n    convex_hull =&gt; 1,\n    axes        =&gt; [2,0],\n)\n\n#  A convex hull with holes and \"half\" concave.\nsp_in_label_range(\n    label        =&gt; 'Genus:Sp1',\n    concave_hull =&gt; 1,\n    allow_holes  =&gt; 1,\n    hull_ratio   =&gt; 0.5,\n)\n\n\nsp_in_line_with\nAre we in line with a vector radiating out from the processing cell? Use the axes argument to control which are used (default is [0,1]).\nRequired args: none\nOptional args: axes, vector_angle, vector_angle_deg\nExample:\nsp_in_line_with (vector_angle =&gt; Math::Trig::pip2) #  pi/2 = 90 degree angle\n\n\nsp_is_left_of\nAre we to the left of a vector radiating out from the processing cell? Use the axes argument to control which are used (default is [0,1]).\nRequired args: none\nOptional args: axes, vector_angle, vector_angle_deg\nExample:\nsp_is_left_of (vector_angle =&gt; 1.5714)\n\n\nsp_is_right_of\nAre we to the right of a vector radiating out from the processing cell? Use the axes argument to control which are used (default is [0,1]).\nRequired args: none\nOptional args: axes, vector_angle, vector_angle_deg\nExample:\nsp_is_right_of (vector_angle =&gt; 1.5714)\n\n\nsp_match_regex\nSelect all neighbours with an axis matching a regular expression\nRequired args: re\nOptional args: axis, type\nExample:\n#  use any neighbour where the first axis includes the text \"type1\"\nsp_match_regex (re =&gt; qr'type1', axis =&gt; 0, type =&gt; 'nbr')\n\n# match only when the third neighbour axis starts with\n# the processing group's second axis\nsp_match_regex (re =&gt; qr/^$coord[2]/, axis =&gt; 2, type =&gt; 'nbr')\n\n# match the whole coordinate ID (element name)\n# where Biome can be 1 or 2 and the rest of the name contains \"dry\"\nsp_match_regex (re =&gt; qr/^Biome[12]:.+dry/)\n\n# Set a definition query to only use groups where the\n# third axis ends in 'park' (case insensitive)\nsp_match_regex (text =&gt; qr{park$}i, axis =&gt; 2, type =&gt; 'proc')\n\n\nsp_match_text\nSelect all neighbours matching a text string\nRequired args: text\nOptional args: axis, type\nExample:\n#  use any neighbour where the first axis has value of \"type1\"\nsp_match_text (text =&gt; 'type1', axis =&gt; 0, type =&gt; 'nbr')\n\n# match only when the third neighbour axis is the same\n#   as the processing group's second axis\nsp_match_text (text =&gt; $coord[2], axis =&gt; 2, type =&gt; 'nbr')\n\n# match where the whole coordinate ID (element name)\n# is 'Biome1:savannah forest'\nsp_match_text (text =&gt; 'Biome1:savannah forest')\n\n# Set a definition query to only use groups with 'NK' in the third axis\nsp_match_text (text =&gt; 'NK', axis =&gt; 2, type =&gt; 'proc')\n\n\nsp_point_in_cluster\nReturns true when the group is in a cluster or region grower output cluster.\nRequired args: output\nOptional args: element, from_node\nExample:\n#  Use any element that is a terminal in the cluster output.\n#  This is useful if the cluster analysis was run under\n#  a definition query and you want the same set of groups.\nsp_point_in_cluster (\n  output       =&gt; \"some_cluster_output\",\n)\n\n#  Now specify a cluster within the output\nsp_point_in_cluster (\n  output       =&gt; \"some_cluster_output\",\n  from_node    =&gt; '118___',  #  use the node's name\n)\n\n#  Specify an element to check instead of the current\n#  processing element.\nsp_point_in_cluster (\n  output       =&gt; \"some_cluster_output\",\n  from_node    =&gt; '118___',  #  use the node's name\n  element      =&gt; '123:456', #  specify an element to check\n)\n\n\nsp_point_in_poly\nSelect groups that occur within a user-defined polygon (see sp_point_in_poly_shape for an alternative)\nRequired args: polygon\nOptional args: point\nExample:\n# Is the neighbour coord in a square polygon?\nsp_point_in_poly (\n    polygon =&gt; [[0,0],[0,1],[1,1],[1,0],[0,0]],\n    point   =&gt; \\@nbrcoord,\n)\n\n\nsp_point_in_poly_shape\nSelect groups that occur within a polygon or polygons extracted from a shapefile\nRequired args: file\nOptional args: axes, field_name, field_val, no_cache, point\nExample:\n# Is the neighbour coord in a shapefile?\nsp_point_in_poly_shape (\n    file  =&gt; 'c:\\biodiverse\\data\\coastline_lamberts',\n    point =&gt; \\@nbrcoord,\n);\n# Is the neighbour coord in a shapefile's second polygon (counting from 1)?\nsp_point_in_poly_shape (\n    file      =&gt; 'c:\\biodiverse\\data\\coastline_lamberts',\n    field_val =&gt; 2,\n    point     =&gt; \\@nbrcoord,\n);\n# Is the neighbour coord in a polygon with value 2 in the OBJECT_ID field?\nsp_point_in_poly_shape (\n    file       =&gt; 'c:\\biodiverse\\data\\coastline_lamberts',\n    field_name =&gt; 'OBJECT_ID',\n    field_val  =&gt; 2,\n    point      =&gt; \\@nbrcoord,\n);\n\n\nsp_points_in_same_cluster\nReturns true when two points are within the same cluster or region grower group, or if neither point is in the selected clusters/groups.\nRequired args: output\nOptional args: from_node, group_by_depth, num_clusters, target_distance\nExample:\n#  Try to use the highest four clusters from the root.\n#  Note that the next highest number will be used\n#  if four is not possible, e.g. there are five\n#  siblings below the root.  Fewer will be returned\n#  if the tree has insufficient tips.\nsp_points_in_same_cluster (\n  output       =&gt; \"some_cluster_output\",\n  num_clusters =&gt; 4,\n)\n\n#  Cut the tree at a distance of 0.25 from the tips\nsp_points_in_same_cluster (\n  output          =&gt; \"some_cluster_output\",\n  target_distance =&gt; 0.25,\n)\n\n#  Cut the tree at a depth of 3.\n#  The root is depth 1.\nsp_points_in_same_cluster (\n  output          =&gt; \"some_cluster_output\",\n  target_distance =&gt; 3,\n  group_by_depth  =&gt; 1,\n)\n\n#  work from an arbitrary node\nsp_points_in_same_cluster (\n  output       =&gt; \"some_cluster_output\",\n  num_clusters =&gt; 4,\n  from_node    =&gt; '118___',  #  use the node's name\n)\n\n#  target_distance is ignored if num_clusters is set\nsp_points_in_same_cluster (\n  output          =&gt; \"some_cluster_output\",\n  num_clusters    =&gt; 4,\n  target_distance =&gt; 0.25,\n)\n\n\nsp_points_in_same_poly_shape\nReturns true when two points are within the same shapefile polygon\nRequired args: file\nOptional args: axes, no_cache, point1, point2\nExample:\n#  define neighbour sets using a shapefile\nsp_points_in_same_poly_shape (file =&gt; 'path/to/a/shapefile')\n\n#  return true when the neighbour coord is in the same\n#  polygon as an arbitrary point\nsp_points_in_same_poly_shape (\n    file   =&gt; 'path/to/a/shapefile',\n    point1 =&gt; [10,20],\n)\n\n#  reverse the axes\nsp_points_in_same_poly_shape (\n    file =&gt; 'path/to/a/shapefile',\n    axes =&gt; [1,0],\n)\n\n#  compare against the second and third axes of your data\n#  e.g. maybe you have time as the first basedata axis\nsp_points_in_same_poly_shape (\n    file =&gt; 'path/to/a/shapefile',\n    axes =&gt; [1,2],\n)\n\n\nsp_rectangle\nA rectangle. Assessed against all dimensions by default (more properly called a hyperbox) but use the optional axes =&gt; [] arg to specify a subset. Uses group (map) distances.\nRequired args: sizes\nOptional args: axes\nExample:\n#  A rectangle of equal size on the first two axes,\n#  and 100 on the third.\nsp_rectangle (sizes =&gt; [100000, 100000, 100])\n\n#  The same, but with the axes reordered\n#  (an example of using the axes argument)\nsp_rectangle (\n    sizes =&gt; [100000, 100, 100000],\n    axes  =&gt; [0, 2, 1],\n)\n\n#  Use only the first an third axes\nsp_rectangle (sizes =&gt; [100000, 100000], axes =&gt; [0,2])\n\n\nsp_redundancy_greater_than\nReturn true if the sample redundancy for an element is greater than the threshold.\nRequired args: threshold\nOptional args: element\nExample:\n#  Uses the processing group for definition queries,\n#  and the neighbour group for spatial conditions.\n#  In this example, # any group with a redundncy\n#  score of 0.5 or fewerless will return false\nsp_redundancy_greater_than (\n    threshold =&gt; 0.5,\n)\n\nsp_redundancy_greater_than (\n    element   =&gt; '128:254',  #  an arbitrary element\n    threshold =&gt; 0.2,          #  with a threshold of 0.2\n)\n\n\nsp_richness_greater_than\nReturn true if the richness for an element is greater than the threshold.\nRequired args: threshold\nOptional args: element\nExample:\n#  Uses the processing group for definition queries,\n#  and the neigbour group for spatial conditions.\nsp_richness_greater_than (\n    threshold =&gt; 3, # any group with 3 or fewer labels will return false\n)\n\nsp_richness_greater_than (\n    element   =&gt; '128:254',  #  an arbitrary element\n    threshold =&gt; 4,          #  with a threshold of 4\n)\n\n\nsp_select_all\nSelect all elements as neighbours\nRequired args: none\nOptional args: none\nExample:\nsp_select_all() #  select every group\n\n\nsp_select_block\nSelect a subset of all available neighbours based on a block sample sequence\nRequired args: size\nOptional args: count, prng_seed, random, reverse_order, use_cache\nExample:\n# Select up to two groups per block with each block being 5 groups\non a side where the group size is 100\nsp_select_block (size =&gt; 500, count =&gt; 2)\n\n#  Now do it non-randomly and start from the lower right\nsp_select_block (size =&gt; 500, count =&gt; 10, random =&gt; 0, reverse =&gt; 1)\n\n#  Rectangular block with user specified PRNG starting seed\nsp_select_block (size =&gt; [300, 500], count =&gt; 1, prng_seed =&gt; 454678)\n\n# Lower memory footprint (but longer running times for neighbour searches)\nsp_select_block (size =&gt; 500, count =&gt; 2, clear_cache =&gt; 1)\n\n\nsp_select_element\nSelect a specific element. Basically the same as sp_match_text, but with optimisations enabled\nRequired args: element\nOptional args: type\nExample:\n# match where the whole coordinate ID (element name)\n# is 'Biome1:savannah forest'\nsp_select_element (element =&gt; 'Biome1:savannah forest')\n\n\nsp_select_sequence\nSelect a subset of all available neighbours based on a sample sequence (note that groups are sorted south-west to north-east)\nRequired args: frequency\nOptional args: cycle_offset, first_offset, reverse_order, use_cache\nExample:\n# Select every tenth group (groups are sorted alphabetically)\nsp_select_sequence (frequency =&gt; 10)\n\n#  Select every tenth group, starting from the third\nsp_select_sequence (frequency =&gt; 10, first_offset =&gt; 2)\n\n#  Select every tenth group, starting from the third last\n#  and working backwards\nsp_select_sequence (\n    frequency     =&gt; 10,\n    first_offset  =&gt;  2,\n    reverse_order =&gt;  1,\n)\n\n\nsp_self_only\nSelect only the processing group\nRequired args: none\nOptional args: none\nExample:\nsp_self_only() #  only use the proceessing cell\n\n\nsp_spatial_output_passed_defq\nReturns 1 if an element passed the definition query for a previously calculated spatial output\nRequired args: none\nOptional args: element, output\nExample:\n#  Used for spatial or cluster type analyses:\n#  The simplest case is where the current\n#  analysis includes a def query and you\n#  want to use it in a spatial condition.\nsp_spatial_output_passed_defq();\n\n#  Using another output in this basedata\n#  In this case the output is called 'analysis1'\nsp_spatial_output_passed_defq(\n    output =&gt; 'analysis1',\n);\n\n#  Return true if a specific element passed the def query\nsp_spatial_output_passed_defq(\n    element =&gt; '153.5:-32.5',\n);\n\n\nsp_square\nAn overlapping square assessed against all dimensions (more properly called a hypercube). Uses group (map) distances.\nRequired args: size\nOptional args: none\nExample:\n#  An overlapping square, cube or hypercube\n#  depending on the number of axes\n#   Note - you cannot yet specify which axes to use\n#   so it will be square on all sides\nsp_square (size =&gt; 300000)\n\n\nsp_square_cell\nA square assessed against all dimensions (more properly called a hypercube). Uses 'cell' distances.\nRequired args: size\nOptional args: none\nExample:\nsp_square_cell (size =&gt; 3)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "variables.html",
    "href": "variables.html",
    "title": "4  Variables",
    "section": "",
    "text": "4.1 Examples using variables\nThere are several different sets of variables implemented that the system recognises. Any undeclared variable you use that does not occur in this list will be treated as a zero or as undefined (depending on where it is used), which means it will probably not behave as you expect. An example declaring variables is given below.\nAs a general rule, uppercase letters denote absolute values, lower case letters denote signed values (positive or negative). Positive values are north, east, above, or to the right. Negative values are south, west, below or to the left.\n$D is the absolute euclidean distance from the processing group to a candidate neighbour group across all dimensions.\n$D[0], $D[1] are the absolute euclidean distances in dimension 0 and 1. In most cases $D[0] will be the X (longitude) dimension, $D[1] will be the Y (latitude) dimension. The library functions can actually handle more dimensions than this (eg $D[2] for altitude or depth), but the GUI is not set up to display them (it will plot the data using the first two axes, so only the first of any overlapping groups will be visible).\n$d[0], $d[1] and so forth are the signed euclidean distance in dimension 0, 1 etc. This allows us to extract all groups within some distance in some direction. As with standard Cartesian plots, negative values are to the left or below (west or south), positive values to the right or above (east or north). As with $D[0], $d[0] will normally be the X dimension, $d[1] will be the Y dimension.\nNote that using abs($d[1]) is the same as using $D[1].\n$C, $C[0], $C[1], $c[0], $c[1] are the same as the euclidean distance variables ($D etc) but operate directly in group (cell) units. If your groups were imported using a cellsize of 100,000, then $D[1] &lt; 100000 is the same as $C[1] &lt; 1. Note, however, that if you used a different resolution in each dimension, then the map and cell distances are not directly comparable. For example, if cell sizes of 100 and 200 were used for axes 0 and 1 then $C&lt;1 is the same as sqrt($C[0]**2 + $C[1]**2) &lt; 1 which is sqrt(($D[0]/100)**2 + ($D[1]/200)**2) &lt; 1, and not $D&lt;100.\n$coord_id1 is the name of the processing coord, $coord_id2 is the name of the neighbour coord.\n$coord[0], $coord[1] are the coordinate values of the processing group in the first and second dimensions. As per the above, think of these as X and Y, except that $coord[5] will also work if your groups have six or more dimensions. Note that the $coord[] variables do not necessarily work properly with the spatial index, so you might need to turn the index off when using them.\n$nbrcoord[0] etc are analogous to $coord[0] etc, except that they are the coordinates for the current neighbour group.\nNote that the array index starts from zero, so $coord[1] is the second coordinate axis and not the first. This differs from systems like Fortran, R and AWK, but is consistent with many other programming languages like C, Rust and Python.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Variables</span>"
    ]
  },
  {
    "objectID": "variables.html#examples-using-variables",
    "href": "variables.html#examples-using-variables",
    "title": "4  Variables",
    "section": "",
    "text": "Set the neighbours to be those groups where the absolute distance from the processing group is less than 100,000.\n\n$D &lt;= 100000\n\nSelect all groups to the west of the processing group.\n\n$d[0] &lt; 0\n\nSelect all groups to the north-east of the processing group.\n\n$d[0] &gt; 0 && $d[1] &gt; 0\n\nThe absolute distance in the first (eg x) dimension is less than 100,000 AND the signed distance is greater than 100,000. This will result in a neighbourhood that is a column of groups 200,000 map units east-west, and including all groups 100,000 map units north of the processing group. Not that you would normally want a neighbourhood like this...\n\n$D[0] &lt;= 100000 && $d[1] &gt;= 100000\n\nSelect everything north of 6000000 (e.g. if using UTM coordinates as axes 0 and 1). This is an example that could be used as a definition query, and will not work well as a neighbourhood (use $nbr_y instead of $y for that).\n\n$y &gt; 6000000\n\nSelect everything within a rectangle. This is another useful definition query.\n\n$y &gt; 6000000 && $y &lt;= 6100000 && $x &gt; 580000 && $x &lt;= 600000\n\nSelect a specific processing coord (495:595), useful as a definition query to use only one group. Note the use of the eq operator - this matches text.\n\n$coord_id1 eq '495:595'",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Variables</span>"
    ]
  },
  {
    "objectID": "variables.html#declaring-variables-and-using-more-complex-functions",
    "href": "variables.html#declaring-variables-and-using-more-complex-functions",
    "title": "4  Variables",
    "section": "4.2 Declaring variables and using more complex functions",
    "text": "4.2 Declaring variables and using more complex functions\nVariable declaration is done as per Perl syntax. For example:\nmy $some_var = 10;\nreturn ($D / $some_var) &lt;= 100;\nThis trivial example evaluates to true if the absolute distance divided by 10 (the value in variable $some_var) is less than 100. The semicolon denotes a separation of statements to be processed in sequence, such that this example could be written on one line. The result of the last statement is what is returned to the analysis to determine if the group is part of the neighbourhood or not. It is evaluated as true or false. The word return is not actually needed in this case, but does make things clearer when there are multiple lines of code.\nA more complex function might involve an ellipse (although you could just use sp_ellipse (major_radius =&gt; 300000, minor_radius =&gt; 100000, rotate_angle =&gt; 1.5714))\nmy $major_radius = 300000; # longest axis\nmy $minor_radius = 100000; # shortest axis\n\n# set the offset in radians, anticlockwise (1.5714 = PI/2 = north)\nmy $rotate_angle = 1.5714;\n\n# now calc the bearing to rotate the coords by\nmy $bearing = atan2 ($d[0], $d[1]) + $rotate_angle;\n\n#  and rotate them\nmy $r_x = cos ($bearing) * $D; # rotated x coord\nmy $r_y = sin ($bearing) * $D; # rotated y coord\n\n#  get the scaled distances in each direction\nmy $a_dist = ($r_y ** 2) / ($major_radius ** 2);\nmy $b_dist = ($r_x ** 2) / ($minor_radius ** 2);\n\n# this last line evaluates to 1 (true) if the candidate\n#   neighbour is within or on the edge of the ellipse, \n#   and 0 (false) otherwise\nreturn ($a_dist + $b_dist) &lt;= 1;\nNote the use of the word my. This is required to declare your own variables in the correct scope. If it is not used then the variables will not work properly. Do not declare any of the pre-calculated Biodiverse variables with this ($D etc) - they already exist and redeclaring will overprint them, causing unpredictable results.\nIf you wish to know if your function works with the spatial index then run a moving window analysis twice, once with and once without the spatial index, using the list indices generated by the Element Counts calculations to get the lists of neighbours. Export the results to CSV and use a difference tool to compare the results.\nFunctions available by default are those in the Math::Trig library, plus POSIX::fmod().\nTo access environment variables you have set, just use $ENV{variable_name}, eg $ENV{my_default_radius}.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Variables</span>"
    ]
  }
]