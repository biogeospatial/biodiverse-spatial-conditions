[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Biodiverse Spatial Conditions",
    "section": "",
    "text": "1 Biodiverse Spatial Conditions\nVersion 5.0\nBiodiverse is a tool for the spatial analysis of biological and related diversity\nShawn W Laffan\nFeb 2026\nThere is also a blog that provides updates and tips about functionality. It can be accessed through http://biodiverse-analysis-software.blogspot.com.au/\nIf you have question about the software then please start a discussion at https://github.com/shawnlaffan/biodiverse/discussions or post a question at https://groups.google.com/forum/#!forum/biodiverse-users\nThis work is licensed under a Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>**Biodiverse Spatial Conditions**</span>"
    ]
  },
  {
    "objectID": "spatial_conditions.html",
    "href": "spatial_conditions.html",
    "title": "2  Biodiverse Spatial Conditions",
    "section": "",
    "text": "3 Uses for spatial conditions\nSpatial conditions are core to the Biodiverse system. They are used to specify both neighbourhoods used in the analyses, and also the definition queries used to restrict the calculations to a subset of groups.\nSpatial conditions are used both to define the neighbourhoods of the spatial analyses and the definition queries used to constrain the set of groups used in the analyses.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Biodiverse Spatial Conditions</span>"
    ]
  },
  {
    "objectID": "spatial_conditions.html#neighbourhoods",
    "href": "spatial_conditions.html#neighbourhoods",
    "title": "2  Biodiverse Spatial Conditions",
    "section": "3.1 Neighbourhoods",
    "text": "3.1 Neighbourhoods\nNeighbourhoods are essential for any spatial analysis, as it is through these that one can define the set of groups to be considered in an analysis. In the moving window analyses these determine which groups are compared with which other groups. In the cluster analyses they determine which groups are considered candidates to be clustered together. It is also possible to define neighbourhoods for spatially constrained randomisations (see Laffan and Crisp, 2003, J Biogeog).\nBefore we describe the process, some definitions are needed. The processing group is the group being considered in the analysis at some iteration, and to which the results for that iteration are assigned. A group is a member of the processing group's set of neighbours (is a neighbouring group) if the spatial condition evaluates to true.\nA spatial analysis progressively iterates over each group that passes the definition query, assessing every other group for membership in neighbour set 1 or 2. The selected indices are then calculated using the groups that occur in neighbour sets 1 and 2 (and their labels and other properties as required by the calculations).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Biodiverse Spatial Conditions</span>"
    ]
  },
  {
    "objectID": "spatial_conditions.html#definition-queries",
    "href": "spatial_conditions.html#definition-queries",
    "title": "2  Biodiverse Spatial Conditions",
    "section": "3.2 Definition Queries",
    "text": "3.2 Definition Queries\nThese differ from neighbourhoods as they assess only the processing group to determine if calculations should be run for it or not. They use the same syntax as for neighbourhoods, but the system will commonly complain if a condition requiring a neighbouring group is used.\nNote that groups that fail the definition query are still considered for membership of neighbour sets of those that pass. Use a definition query in conjunction with an appropriate neighbourhood definition if you want to exclude some groups from neighbour sets as well. For example, you could use sp_match_text (axis =&gt; 2, text =&gt; 'fred', type =&gt; 'proc') for the definition query and sp_match_text (axis =&gt; 2, text =&gt; 'fred', type =&gt; 'nbr') for the neighbourhood. This will restrict calculations to those groups with a third axis of 'fred', and also exclude any group without fred in the third axis from the neighbour sets of those groups processed.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Biodiverse Spatial Conditions</span>"
    ]
  },
  {
    "objectID": "spatial_conditions.html#locale-issues",
    "href": "spatial_conditions.html#locale-issues",
    "title": "2  Biodiverse Spatial Conditions",
    "section": "4.1 Locale issues",
    "text": "4.1 Locale issues\nIf you are using a locale where the radix character (the decimal place marker) is a comma then you need to remember to use a dot instead. For example, this code sp_circle (radius =&gt; 5,3) should be sp_circle (radius =&gt; 5.3) or you will receive warnings about uneven arguments used to define a hash.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Biodiverse Spatial Conditions</span>"
    ]
  },
  {
    "objectID": "spatial_conditions.html#available-functions",
    "href": "spatial_conditions.html#available-functions",
    "title": "2  Biodiverse Spatial Conditions",
    "section": "6.1 Available functions",
    "text": "6.1 Available functions\nThe available functions in version 5.0 are: sp_annulus, sp_block, sp_circle, sp_circle_cell, sp_ellipse, sp_get_spatial_output_list_value, sp_group_not_empty, sp_in_label_ancestor_range, sp_in_label_range, sp_in_line_with, sp_is_left_of, sp_is_right_of, sp_match_regex, sp_match_text, sp_point_in_cluster, sp_point_in_poly, sp_point_in_poly_shape, sp_points_in_same_cluster, sp_points_in_same_poly_shape, sp_rectangle, sp_redundancy_greater_than, sp_richness_greater_than, sp_select_all, sp_select_block, sp_select_element, sp_select_sequence, sp_self_only, sp_spatial_output_passed_defq, sp_square, sp_square_cell,\n\nsp_annulus\nAn annulus. Assessed against all dimensions by default but use the optional \"axes =&gt; []\" arg to specify a subset. Uses group (map) distances.\nRequired args: inner_radius, outer_radius\nOptional args: axes\nExample:\n#  an annulus assessed against all axes\nsp_annulus (inner_radius =&gt; 2000000, outer_radius =&gt; 4000000)\n\n#  an annulus assessed against axes 0 and 1\nsp_annulus (inner_radius =&gt; 2000000, outer_radius =&gt; 4000000, axes =&gt; [0,1])\n\n\nsp_block\nA non-overlapping block. Set an axis to undef to ignore it.\nRequired args: size\nOptional args: origin\nExample:\nsp_block (size =&gt; 3)\nsp_block (size =&gt; [3,undef,5]) #  rectangular block, ignores second axis\n\n\nsp_circle\nA circle. Assessed against all dimensions by default (more properly called a hypersphere) but you can use the optional \"axes =&gt; []\" arg to specify a subset. Uses group (map) distances.\nRequired args: radius\nOptional args: axes\nExample:\n#  A circle of radius 1000 across all axes\nsp_circle (radius =&gt; 1000)\n\n#  use only axes 0 and 3\nsp_circle (radius =&gt; 1000, axes =&gt; [0, 3])\n\n\nsp_circle_cell\nA circle. Assessed against all dimensions by default (more properly called a hypersphere) but you can use the optional \"axes =&gt; []\" arg to specify a subset. Uses cell (map) distances.\nRequired args: radius\nOptional args: none\nExample:\n#  A circle of radius 3 cells across all axes\nsp_circle (radius =&gt; 3)\n\n#  use only axes 0 and 3\nsp_circle_cell (radius =&gt; 3, axes =&gt; [0, 3])\n\n\nsp_ellipse\nA two dimensional ellipse. Use the 'axes' argument to control which are used (default is [0,1]). The default rotate_angle is 0, such that the major axis is east-west.\nRequired args: major_radius, minor_radius\nOptional args: axes, rotate_angle, rotate_angle_deg\nExample:\n# North-south aligned ellipse\nsp_ellipse (\n    major_radius =&gt; 300000,\n    minor_radius =&gt; 100000,\n    axes         =&gt; [0,1],\n    rotate_angle =&gt; 1.5714,\n)\n\n\nsp_get_spatial_output_list_value\nObtain a value from a list in a previously calculated spatial output.\nRequired args: index, output\nOptional args: element, list, no_error_if_no_index\nExample:\n#  Get the spatial results value for the current neighbour group\n# (or processing group if used as a def query)\nsp_get_spatial_output_list_value (\n    output  =&gt; 'sp1',              #  using spatial output called sp1\n    list    =&gt; 'SPATIAL_RESULTS',  #  from the SPATIAL_RESULTS list\n    index   =&gt; 'PE_WE_P',          #  get index value for PE_WE_P\n)\n\n#  Get the spatial results value for group 128:254\n#  Note that the SPATIAL_OUTPUTS list is assumed if\n#  no 'list' arg is passed.\nsp_get_spatial_output_list_value (\n    output  =&gt; 'sp1',\n    element =&gt; '128:254',\n    index   =&gt; 'PE_WE_P',\n)\n\n\nsp_group_not_empty\nIs a basedata group non-empty? (i.e. contains one or more labels)\nRequired args: none\nOptional args: element\nExample:\n# Restrict calculations to those non-empty groups.\n#  Will use the processing group if a def query,\n#  the neighbour group otherwise.\nsp_group_not_empty ()\n\n# The same as above, but being specific about which group (element) to test.\n#  This is probably best used in cases where the element\n#  to check is varied spatially.}\nsp_group_not_empty (element =&gt; '5467:9876')\n\n\nsp_in_label_ancestor_range\nIs a group within the range of a label's ancestor?\nReturns true if the group falls within the range of any of the any of the ancestor's terminal descendant ranges. The range is by default defined as the set of groups in the basedata containing that label. Polygons can also be specified (see below).\nThe ancestor is by default defined by length along the path to the root node. Setting the by_depth option to true uses the number of ancestors. The by_tip_count option finds the first ancestor with at least the target number of tips while by_desc_count uses the number of descendants (tips and internals). The by_len_sum finds the first ancestor for which the sum of its descendant branch lengths plus its own length is greater than the target.\nNegative length or depth target values search the path from the root to the specified node. If a by_xxx_count option is used then it is treated as zero and returns the specified label.\nThe target argument determines how far up or down the tree the ancestor is searched for. When using length, the distance includes the tipwards extent of the branch. The depth is calculated as the number of ancestors.\nIf the target value exceeds that to (or of) the root node then the root or label node is returned for positive or negative dist values, respectively.\nAn internal branch can be specified as the label. Specifying a target of 0 is one means to use the range of an internal node.\nReturns false if the label is not associated with a node on the tree.\nWhen the as_frac argument is true then target is treated as a fraction of the distance to the root node, the number of tips, or the sum of all branches, as appropriate.\nIf the eq argument is set then the branch lengths are all treated as of equal length (the mean of the non-zero branch lengths). This is the same as the alternate tree used in CANAPE, and zero length branches remain zero.\nIf the rw argument is set then the branches are range weighted. This is the same as the range weighted alternate tree in CANAPE.\nThe underlying algorithm checks each of the terminal ranges using sp_in_label_range(). This means the search can also use the convex/concave hull or circumcircle of each terminal, as well as setting other arguments such as the buffer_dist and using a default label in some circumstances.\nNote that the range of each of the ancestor's tips is assessed separately. The ranges are not aggregated before a hull or circumcircle is calculated.\nRequired args: label, target\nOptional args: allow_holes, as_frac, axes, buffer_dist, by_depth, by_tip_count, circumcircle, concave_hull, convex_hull, hull_ratio, type\nExample:\n# Are we in the range of an ancestor of Genus:Sp1?\nsp_in_label_ancestor_range(label =&gt; 'Genus:Sp1', target =&gt; 0.5)\n\n# Are we in the range of the \"grandmother\" of Genus:Sp1?\nsp_in_label_ancestor_range(\n  label    =&gt; 'Genus:Sp1',\n  target   =&gt; 2,\n  by_depth =&gt; 1,\n)\n\n# Are we in the range of the first ancestor with 6 or more tips?\nsp_in_label_ancestor_range(\n  label        =&gt; 'Genus:Sp1',\n  target       =&gt; 6,\n  by_tip_count =&gt; 1,\n)\n\n#  Are we in any of the tips' convex hulls?\nsp_in_label_ancestor_range(\n  label       =&gt; 'Genus:Sp1',\n  target      =&gt; 0.5,\n  convex_hull =&gt; 1,\n)\n\n#  Are we in any of the tips' concave hulls with a ratio parameter of 0.5?\nsp_in_label_ancestor_range(\n  label        =&gt; 'Genus:Sp1',\n  target       =&gt; 0.5,\n  concave_hull =&gt; 1,\n  hull_ratio   =&gt; 0.5,\n)\n\n#  Are we in any of the tips' circumscribing circles?\nsp_in_label_ancestor_range(\n  label        =&gt; 'Genus:Sp1',\n  target       =&gt; 0.5,\n  circumcircle =&gt; 1,\n)\n\n#  Are we in the range of the ancestor for which the sum of\n#  branch lengths below and including it is 10,000?\nsp_in_label_ancestor_range(\n  label      =&gt; 'Genus:Sp1',\n  target     =&gt; 10000,\n  by_len_sum =&gt; 1,\n)\n\n#  Are we in the range of the ancestor for which the sum of\n#  number of branches below is at least 10?\nsp_in_label_ancestor_range(\n  label      =&gt; 'Genus:Sp1',\n  target     =&gt; 10,\n  by_desc_count =&gt; 1,\n)\n\n\n\nsp_in_label_range\nIs a group within a label's range?\nThis is by default assessed as a check of whether the label is found in the processing group but can be generalised by passing the convex_hull or circumcircle arguments.\nThe type argument determines if the processing or neighbour group is assessed. Normally this can be left as the default.\nThe convex_hull returns true if the processing group is within the convex hull defined by the groups that form the label range.\nThe circumcircle returns true if the processing group is within the minimum circumscribing circle that includes all of the label range groups.\nBoth the latter two arguments use the first two axes by default and will return an error if there is only one axis. If you have more than two axes and wish to assess different ones then pass the axes argument. (This argument is ignored for the default case).\nIf both convex_hull and circumcircle arguments are set to true then the circumcircle is used.\nAn optional buffer_dist argument can be used to adjust the size of the convex hull or circumcircle. As is standard with GIS buffering, positive values increase the area while negative values decrease it.\nThe label argument should normally be specified but in some circumstances a default is set (e.g. when a randomisation seed location is set).\nRequired args: label\nOptional args: allow_holes, axes, buffer_dist, circumcircle, concave_hull, convex_hull, hull_ratio, type\nExample:\n# Are we in the range of label called Genus:Sp1?\nsp_in_label_range(label =&gt; 'Genus:Sp1')\n\n#  Are we in the convex hull?\nsp_in_label_range(label =&gt; 'Genus:Sp1', convex_hull =&gt; 1)\n\n#  Are we in the maximally concave hull?\nsp_in_label_range(label =&gt; 'Genus:Sp1', concave_hull =&gt; 1)\n\n#  Are we in a slightly less concave hull?\nsp_in_label_range(label =&gt; 'Genus:Sp1', concave_hull =&gt; 1, hull_ratio =&gt; 0.3)\n\n#  Are we in a slightly less concave hull allowing for holes?\nsp_in_label_range(\n    label        =&gt; 'Genus:Sp1',\n    concave_hull =&gt; 1,\n    hull_ratio   =&gt; 0.3,\n    allow_holes  =&gt; 1,\n)\n\n#  Are we in the circumscribing circle?\nsp_in_label_range(label =&gt; 'Genus:Sp1', circumcircle =&gt; 1)\n\n#  Are we in the convex hull with a buffer of 100,000 units?\nsp_in_label_range(\n    label       =&gt; 'Genus:Sp1',\n    convex_hull =&gt; 1,\n    buffer_dist =&gt; 100000,\n)\n\n#  Buffers can be negative, in which case the\n#  convex/concave hull or circumcircle is shrunk\nsp_in_label_range(\n    label       =&gt; 'Genus:Sp1',\n    convex_hull =&gt; 1,\n    buffer_dist =&gt; -100000,\n)\n\n#  Are we in the convex hull defined using the\n#  coordinates from the third and first axes?\nsp_in_label_range(\n    label       =&gt; 'Genus:Sp1',\n    convex_hull =&gt; 1,\n    axes        =&gt; [2,0],\n)\n\n\nsp_in_line_with\nAre we in line with a vector radiating out from the processing cell? Use the 'axes' argument to control which are used (default is [0,1]).\nRequired args: none\nOptional args: axes, vector_angle, vector_angle_deg\nExample:\nsp_in_line_with (vector_angle =&gt; Math::Trig::pip2) #  pi/2 = 90 degree angle\n\n\nsp_is_left_of\nAre we to the left of a vector radiating out from the processing cell? Use the 'axes' argument to control which are used (default is [0,1]).\nRequired args: none\nOptional args: axes, vector_angle, vector_angle_deg\nExample:\nsp_is_left_of (vector_angle =&gt; 1.5714)\n\n\nsp_is_right_of\nAre we to the right of a vector radiating out from the processing cell? Use the 'axes' argument to control which are used (default is [0,1]).\nRequired args: none\nOptional args: axes, vector_angle, vector_angle_deg\nExample:\nsp_is_right_of (vector_angle =&gt; 1.5714)\n\n\nsp_match_regex\nSelect all neighbours with an axis matching a regular expression\nRequired args: re\nOptional args: axis, type\nExample:\n#  use any neighbour where the first axis includes the text \"type1\"\nsp_match_regex (re =&gt; qr'type1', axis =&gt; 0, type =&gt; 'nbr')\n\n# match only when the third neighbour axis starts with\n# the processing group's second axis\nsp_match_regex (re =&gt; qr/^$coord[2]/, axis =&gt; 2, type =&gt; 'nbr')\n\n# match the whole coordinate ID (element name)\n# where Biome can be 1 or 2 and the rest of the name contains \"dry\"\nsp_match_regex (re =&gt; qr/^Biome[12]:.+dry/)\n\n# Set a definition query to only use groups where the\n# third axis ends in 'park' (case insensitive)\nsp_match_regex (text =&gt; qr{park$}i, axis =&gt; 2, type =&gt; 'proc')\n\n\nsp_match_text\nSelect all neighbours matching a text string\nRequired args: text\nOptional args: axis, type\nExample:\n#  use any neighbour where the first axis has value of \"type1\"\nsp_match_text (text =&gt; 'type1', axis =&gt; 0, type =&gt; 'nbr')\n\n# match only when the third neighbour axis is the same\n#   as the processing group's second axis\nsp_match_text (text =&gt; $coord[2], axis =&gt; 2, type =&gt; 'nbr')\n\n# match where the whole coordinate ID (element name)\n# is 'Biome1:savannah forest'\nsp_match_text (text =&gt; 'Biome1:savannah forest')\n\n# Set a definition query to only use groups with 'NK' in the third axis\nsp_match_text (text =&gt; 'NK', axis =&gt; 2, type =&gt; 'proc')\n\n\nsp_point_in_cluster\nReturns true when the group is in a cluster or region grower output cluster.\nRequired args: output\nOptional args: element, from_node\nExample:\n#  Use any element that is a terminal in the cluster output.\n#  This is useful if the cluster analysis was run under\n#  a definition query and you want the same set of groups.\nsp_point_in_cluster (\n  output       =&gt; \"some_cluster_output\",\n)\n\n#  Now specify a cluster within the output\nsp_point_in_cluster (\n  output       =&gt; \"some_cluster_output\",\n  from_node    =&gt; '118___',  #  use the node's name\n)\n\n#  Specify an element to check instead of the current\n#  processing element.\nsp_point_in_cluster (\n  output       =&gt; \"some_cluster_output\",\n  from_node    =&gt; '118___',  #  use the node's name\n  element      =&gt; '123:456', #  specify an element to check\n)\n\n\nsp_point_in_poly\nSelect groups that occur within a user-defined polygon (see sp_point_in_poly_shape for an alternative)\nRequired args: polygon\nOptional args: point\nExample:\n# Is the neighbour coord in a square polygon?\nsp_point_in_poly (\n    polygon =&gt; [[0,0],[0,1],[1,1],[1,0],[0,0]],\n    point   =&gt; \\@nbrcoord,\n)\n\n\nsp_point_in_poly_shape\nSelect groups that occur within a polygon or polygons extracted from a shapefile\nRequired args: file\nOptional args: axes, field_name, field_val, no_cache, point\nExample:\n# Is the neighbour coord in a shapefile?\nsp_point_in_poly_shape (\n    file  =&gt; 'c:\\biodiverse\\data\\coastline_lamberts',\n    point =&gt; \\@nbrcoord,\n);\n# Is the neighbour coord in a shapefile's second polygon (counting from 1)?\nsp_point_in_poly_shape (\n    file      =&gt; 'c:\\biodiverse\\data\\coastline_lamberts',\n    field_val =&gt; 2,\n    point     =&gt; \\@nbrcoord,\n);\n# Is the neighbour coord in a polygon with value 2 in the OBJECT_ID field?\nsp_point_in_poly_shape (\n    file       =&gt; 'c:\\biodiverse\\data\\coastline_lamberts',\n    field_name =&gt; 'OBJECT_ID',\n    field_val  =&gt; 2,\n    point      =&gt; \\@nbrcoord,\n);\n\n\nsp_points_in_same_cluster\nReturns true when two points are within the same cluster or region grower group, or if neither point is in the selected clusters/groups.\nRequired args: output\nOptional args: from_node, group_by_depth, num_clusters, target_distance\nExample:\n#  Try to use the highest four clusters from the root.\n#  Note that the next highest number will be used\n#  if four is not possible, e.g. there are five\n#  siblings below the root.  Fewer will be returned\n#  if the tree has insufficient tips.\nsp_points_in_same_cluster (\n  output       =&gt; \"some_cluster_output\",\n  num_clusters =&gt; 4,\n)\n\n#  Cut the tree at a distance of 0.25 from the tips\nsp_points_in_same_cluster (\n  output          =&gt; \"some_cluster_output\",\n  target_distance =&gt; 0.25,\n)\n\n#  Cut the tree at a depth of 3.\n#  The root is depth 1.\nsp_points_in_same_cluster (\n  output          =&gt; \"some_cluster_output\",\n  target_distance =&gt; 3,\n  group_by_depth  =&gt; 1,\n)\n\n#  work from an arbitrary node\nsp_points_in_same_cluster (\n  output       =&gt; \"some_cluster_output\",\n  num_clusters =&gt; 4,\n  from_node    =&gt; '118___',  #  use the node's name\n)\n\n#  target_distance is ignored if num_clusters is set\nsp_points_in_same_cluster (\n  output          =&gt; \"some_cluster_output\",\n  num_clusters    =&gt; 4,\n  target_distance =&gt; 0.25,\n)\n\n\nsp_points_in_same_poly_shape\nReturns true when two points are within the same shapefile polygon\nRequired args: file\nOptional args: axes, no_cache, point1, point2\nExample:\n#  define neighbour sets using a shapefile\nsp_points_in_same_poly_shape (file =&gt; 'path/to/a/shapefile')\n\n#  return true when the neighbour coord is in the same\n#  polygon as an arbitrary point\nsp_points_in_same_poly_shape (\n    file   =&gt; 'path/to/a/shapefile',\n    point1 =&gt; [10,20],\n)\n\n#  reverse the axes\nsp_points_in_same_poly_shape (\n    file =&gt; 'path/to/a/shapefile',\n    axes =&gt; [1,0],\n)\n\n#  compare against the second and third axes of your data\n#  e.g. maybe you have time as the first basedata axis\nsp_points_in_same_poly_shape (\n    file =&gt; 'path/to/a/shapefile',\n    axes =&gt; [1,2],\n)\n\n\nsp_rectangle\nA rectangle. Assessed against all dimensions by default (more properly called a hyperbox) but use the optional \"axes =&gt; []\" arg to specify a subset. Uses group (map) distances.\nRequired args: sizes\nOptional args: axes\nExample:\n#  A rectangle of equal size on the first two axes,\n#  and 100 on the third.\nsp_rectangle (sizes =&gt; [100000, 100000, 100])\n\n#  The same, but with the axes reordered\n#  (an example of using the axes argument)\nsp_rectangle (\n    sizes =&gt; [100000, 100, 100000],\n    axes  =&gt; [0, 2, 1],\n)\n\n#  Use only the first an third axes\nsp_rectangle (sizes =&gt; [100000, 100000], axes =&gt; [0,2])\n\n\nsp_redundancy_greater_than\nReturn true if the sample redundancy for an element is greater than the threshold.\nRequired args: threshold\nOptional args: element\nExample:\n#  Uses the processing group for definition queries,\n#  and the neighbour group for spatial conditions.\n#  In this example, # any group with a redundncy\n#  score of 0.5 or fewerless will return false\nsp_redundancy_greater_than (\n    threshold =&gt; 0.5,\n)\n\nsp_redundancy_greater_than (\n    element   =&gt; '128:254',  #  an arbitrary element\n    threshold =&gt; 0.2,          #  with a threshold of 0.2\n)\n\n\nsp_richness_greater_than\nReturn true if the richness for an element is greater than the threshold.\nRequired args: threshold\nOptional args: element\nExample:\n#  Uses the processing group for definition queries,\n#  and the neigbour group for spatial conditions.\nsp_richness_greater_than (\n    threshold =&gt; 3, # any group with 3 or fewer labels will return false\n)\n\nsp_richness_greater_than (\n    element   =&gt; '128:254',  #  an arbitrary element\n    threshold =&gt; 4,          #  with a threshold of 4\n)\n\n\nsp_select_all\nSelect all elements as neighbours\nRequired args: none\nOptional args: none\nExample:\nsp_select_all() #  select every group\n\n\nsp_select_block\nSelect a subset of all available neighbours based on a block sample sequence\nRequired args: size\nOptional args: count, prng_seed, random, reverse_order, use_cache\nExample:\n# Select up to two groups per block with each block being 5 groups\non a side where the group size is 100\nsp_select_block (size =&gt; 500, count =&gt; 2)\n\n#  Now do it non-randomly and start from the lower right\nsp_select_block (size =&gt; 500, count =&gt; 10, random =&gt; 0, reverse =&gt; 1)\n\n#  Rectangular block with user specified PRNG starting seed\nsp_select_block (size =&gt; [300, 500], count =&gt; 1, prng_seed =&gt; 454678)\n\n# Lower memory footprint (but longer running times for neighbour searches)\nsp_select_block (size =&gt; 500, count =&gt; 2, clear_cache =&gt; 1)\n\n\nsp_select_element\nSelect a specific element. Basically the same as sp_match_text, but with optimisations enabled\nRequired args: element\nOptional args: type\nExample:\n# match where the whole coordinate ID (element name)\n# is 'Biome1:savannah forest'\nsp_select_element (element =&gt; 'Biome1:savannah forest')\n\n\nsp_select_sequence\nSelect a subset of all available neighbours based on a sample sequence (note that groups are sorted south-west to north-east)\nRequired args: frequency\nOptional args: cycle_offset, first_offset, reverse_order, use_cache\nExample:\n# Select every tenth group (groups are sorted alphabetically)\nsp_select_sequence (frequency =&gt; 10)\n\n#  Select every tenth group, starting from the third\nsp_select_sequence (frequency =&gt; 10, first_offset =&gt; 2)\n\n#  Select every tenth group, starting from the third last\n#  and working backwards\nsp_select_sequence (\n    frequency     =&gt; 10,\n    first_offset  =&gt;  2,\n    reverse_order =&gt;  1,\n)\n\n\nsp_self_only\nSelect only the processing group\nRequired args: none\nOptional args: none\nExample:\nsp_self_only() #  only use the proceessing cell\n\n\nsp_spatial_output_passed_defq\nReturns 1 if an element passed the definition query for a previously calculated spatial output\nRequired args: none\nOptional args: element, output\nExample:\n#  Used for spatial or cluster type analyses:\n#  The simplest case is where the current\n#  analysis includes a def query and you\n#  want to use it in a spatial condition.\nsp_spatial_output_passed_defq();\n\n#  Using another output in this basedata\n#  In this case the output is called 'analysis1'\nsp_spatial_output_passed_defq(\n    output =&gt; 'analysis1',\n);\n\n#  Return true if a specific element passed the def query\nsp_spatial_output_passed_defq(\n    element =&gt; '153.5:-32.5',\n);\n\n\nsp_square\nAn overlapping square assessed against all dimensions (more properly called a hypercube). Uses group (map) distances.\nRequired args: size\nOptional args: none\nExample:\n#  An overlapping square, cube or hypercube\n#  depending on the number of axes\n#   Note - you cannot yet specify which axes to use\n#   so it will be square on all sides\nsp_square (size =&gt; 300000)\n\n\nsp_square_cell\nA square assessed against all dimensions (more properly called a hypercube). Uses 'cell' distances.\nRequired args: size\nOptional args: none\nExample:\nsp_square_cell (size =&gt; 3)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Biodiverse Spatial Conditions</span>"
    ]
  },
  {
    "objectID": "spatial_conditions.html#examples-using-variables",
    "href": "spatial_conditions.html#examples-using-variables",
    "title": "2  Biodiverse Spatial Conditions",
    "section": "7.1 Examples using variables",
    "text": "7.1 Examples using variables\n\nSet the neighbours to be those groups where the absolute distance from the processing group is less than 100,000.\n\n$D &lt;= 100000\n\nSelect all groups to the west of the processing group.\n\n$d[0] &lt; 0\n\nSelect all groups to the north-east of the processing group.\n\n$d[0] &gt; 0 && $d[1] &gt; 0\n\nThe absolute distance in the first (eg x) dimension is less than 100,000 AND the signed distance is greater than 100,000. This will result in a neighbourhood that is a column of groups 200,000 map units east-west, and including all groups 100,000 map units north of the processing group. Not that you would normally want a neighbourhood like this...\n\n$D[0] &lt;= 100000 && $d[1] &gt;= 100000\n\nSelect everything north of 6000000 (e.g. if using UTM coordinates as axes 0 and 1). This is an example that could be used as a definition query, and will not work well as a neighbourhood (use $nbr_y instead of $y for that).\n\n$y &gt; 6000000\n\nSelect everything within a rectangle. This is another useful definition query.\n\n$y &gt; 6000000 && $y &lt;= 6100000 && $x &gt; 580000 && $x &lt;= 600000\n\nSelect a specific processing coord (495:595), useful as a definition query to use only one group. Note the use of the eq operator - this matches text.\n\n$coord_id1 eq '495:595'",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Biodiverse Spatial Conditions</span>"
    ]
  }
]